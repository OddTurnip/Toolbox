<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telegram Sticker Maker - Utilities</title>
    <link rel="icon" type="image/x-icon" href="https://oddturnip.com/favicon_turnip.ico">
    <link rel="stylesheet" href="styles.css">
    <style>
        /* Page-specific styles */
        .drop-zone {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            background: #f8f9ff;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }
        .drop-zone:hover, .drop-zone.dragover {
            background: #eef0ff;
            border-color: #764ba2;
        }
        .drop-zone p {
            color: #666;
            margin: 10px 0;
        }
        .drop-zone .hint {
            font-size: 0.9em;
            color: #888;
        }
        .drop-zone .icon {
            font-size: 3em;
        }
        .hidden-input {
            display: none;
        }
        .editor-section {
            display: none;
            margin-top: 30px;
        }
        .editor-section.active {
            display: block;
        }
        .editor-layout {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }
        .canvas-container {
            flex: 1;
            min-width: 540px;
            text-align: left;
        }
        .boundary-box {
            display: block;
            width: 512px;
            height: 512px;
            border: 2px dashed #e53e3e;
            border-radius: 8px;
            background: repeating-conic-gradient(#f5f5f5 0% 25%, #fff 0% 50%) 50% / 20px 20px;
            position: relative;
            box-sizing: content-box;
        }
        .canvas-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }
        .canvas-wrapper canvas {
            display: block;
        }
        .dimensions {
            font-size: 0.85em;
            color: #888;
            margin-top: 5px;
        }
        .controls {
            flex: 0 0 280px;
            min-width: 250px;
        }
        .control-group {
            margin-bottom: 20px;
            padding: 15px;
        }
        .control-row {
            margin-bottom: 10px;
        }
        .control-row:last-child {
            margin-bottom: 0;
        }
        .control-row label {
            display: block;
            font-size: 0.85em;
            color: #555;
            margin-bottom: 4px;
        }
        .control-row input[type="text"],
        .control-row input[type="number"],
        .control-row textarea {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.95em;
            font-family: inherit;
        }
        .control-row textarea {
            resize: vertical;
            min-height: 60px;
        }
        .control-row input[type="text"]:focus,
        .control-row input[type="number"]:focus,
        .control-row textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
        }
        .inline-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .inline-controls label {
            margin-bottom: 0;
            white-space: nowrap;
        }
        .color-input {
            width: 40px;
            height: 30px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            padding: 2px;
        }
        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .checkbox-row input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .checkbox-row label {
            margin-bottom: 0;
            cursor: pointer;
        }
        .position-hint {
            font-size: 0.75em;
            color: #888;
            margin-top: 4px;
        }
        .color-swatch {
            display: inline-block;
            width: 24px;
            height: 24px;
            border: 2px solid #ccc;
            border-radius: 4px;
            vertical-align: middle;
            margin-left: 8px;
            cursor: pointer;
        }
        .color-swatch:hover {
            border-color: #667eea;
        }
        .bg-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .pick-mode-hint {
            font-size: 0.75em;
            color: #667eea;
            margin-top: 4px;
            font-style: italic;
        }
        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-row input[type="range"] {
            flex: 1;
        }
        .slider-value {
            min-width: 30px;
            text-align: right;
            font-size: 0.9em;
            color: #555;
        }
        .sticker-radio-row {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        .sticker-radio-row label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            margin-bottom: 0;
            padding: 0;
            border: none;
            background: none;
        }
        .sticker-radio-row label:hover {
            background: none;
            border: none;
        }
        .sticker-radio-row input[type="radio"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        @media (max-width: 768px) {
            .editor-layout {
                flex-direction: column;
            }
            .canvas-container {
                min-width: auto;
            }
            .controls {
                flex: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>
                <img src="https://oddturnip.com/img/odd_turnip_480.png" alt="OddTurnip Logo" class="header-logo">
                Telegram Sticker Maker
            </h1>
            <p>Create 512px stickers with optional text overlay</p>
        </header>

        <div class="content">
            <div class="drop-zone" id="dropZone">
                <div class="icon">ðŸ“·</div>
                <p><strong>Drop an image here, click to upload, or paste from clipboard</strong></p>
                <p class="hint">Supports PNG, JPG, GIF, WebP</p>
                <input type="file" id="fileInput" class="hidden-input" accept="image/*">
            </div>

            <div class="editor-section" id="editorSection">
                <div class="editor-layout">
                    <div class="canvas-container">
                        <div class="boundary-box">
                            <div class="canvas-wrapper" id="canvasWrapper">
                                <canvas id="outputCanvas"></canvas>
                            </div>
                        </div>
                        <div class="dimensions" id="dimensions"></div>

                        <div class="actions">
                            <button class="btn btn-primary" id="copyBtn">Copy to Clipboard</button>
                            <button class="btn btn-primary" id="downloadBtn">Download PNG</button>
                            <button class="btn btn-secondary" id="resetBtn">Reset</button>
                        </div>
                        <div class="status" id="status"></div>
                    </div>

                    <div class="controls">
                        <div class="control-group">
                            <h4>Background Removal</h4>
                            <div class="control-row">
                                <div class="checkbox-row">
                                    <input type="checkbox" id="removeBgEnabled">
                                    <label for="removeBgEnabled">Remove Background</label>
                                    <span class="color-swatch" id="bgColorSwatch" title="Click to pick color from image"></span>
                                </div>
                            </div>
                            <div class="control-row">
                                <label>Tolerance</label>
                                <div class="slider-row">
                                    <input type="range" id="bgTolerance" min="0" max="100" value="30">
                                    <span class="slider-value" id="bgToleranceValue">30</span>
                                </div>
                            </div>
                            <div class="control-row">
                                <div class="checkbox-row">
                                    <input type="checkbox" id="autoCropEnabled" checked>
                                    <label for="autoCropEnabled">Auto-crop transparent areas</label>
                                </div>
                            </div>
                            <div class="position-hint">Click image to pick background color</div>
                            <div class="pick-mode-hint" id="pickModeHint" style="display: none;">Click on the image to select background color...</div>
                        </div>

                        <div class="control-group">
                            <h4>Sticker Border</h4>
                            <div class="control-row">
                                <div class="checkbox-row">
                                    <input type="checkbox" id="borderEnabled">
                                    <label for="borderEnabled">Add Sticker Border</label>
                                </div>
                            </div>
                            <div class="control-row">
                                <label>Border Size (px)</label>
                                <div class="slider-row">
                                    <input type="range" id="borderSize" min="1" max="20" value="5">
                                    <span class="slider-value" id="borderSizeValue">5</span>
                                </div>
                            </div>
                            <div class="control-row">
                                <div class="inline-controls">
                                    <label>Border Color</label>
                                    <input type="color" id="borderColor" value="#ffffff" class="color-input">
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <h4>Top Text</h4>
                            <div class="control-row">
                                <textarea id="topText" placeholder="Enter top text..." rows="2"></textarea>
                            </div>
                        </div>

                        <div class="control-group">
                            <h4>Bottom Text</h4>
                            <div class="control-row">
                                <textarea id="bottomText" placeholder="Enter bottom text..." rows="2"></textarea>
                            </div>
                        </div>

                        <div class="control-group">
                            <h4>Reposition Text</h4>
                            <div class="control-row">
                                <div class="sticker-radio-row">
                                    <label>
                                        <input type="radio" name="positionMode" value="top" checked>
                                        Top Text
                                    </label>
                                    <label>
                                        <input type="radio" name="positionMode" value="bottom">
                                        Bottom Text
                                    </label>
                                </div>
                            </div>
                            <div class="position-hint">Click on the canvas to reposition selected text</div>
                        </div>

                        <div class="control-group">
                            <h4>Text Settings</h4>
                            <div class="control-row">
                                <label>Font Size (px)</label>
                                <input type="number" id="fontSize" value="36" min="10" max="100">
                            </div>
                            <div class="control-row">
                                <div class="inline-controls">
                                    <label>Text Color</label>
                                    <input type="color" id="textColor" value="#ffffff" class="color-input">
                                </div>
                            </div>
                            <div class="control-row">
                                <div class="inline-controls">
                                    <input type="checkbox" id="shadowEnabled" checked>
                                    <label for="shadowEnabled">Text Shadow</label>
                                    <input type="color" id="shadowColor" value="#000000" class="color-input">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="footer">
            <div class="footer-links">
                <a href="index.html">&larr; Back to Utilities</a>
                <a href="https://www.oddturnip.com" target="_blank" class="oddturnip-link">
                    <img src="https://oddturnip.com/img/odd_turnip_48.png" alt="OddTurnip Logo">
                    <span>Created by OddTurnip.com</span>
                </a>
            </div>
        </div>
    </div>

    <script>
        const MAX_SIZE = 512;
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const editorSection = document.getElementById('editorSection');
        const outputCanvas = document.getElementById('outputCanvas');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const dimensions = document.getElementById('dimensions');
        const copyBtn = document.getElementById('copyBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const resetBtn = document.getElementById('resetBtn');
        const status = document.getElementById('status');

        // Text controls
        const topTextInput = document.getElementById('topText');
        const bottomTextInput = document.getElementById('bottomText');
        const fontSizeInput = document.getElementById('fontSize');
        const textColorInput = document.getElementById('textColor');
        const shadowEnabledInput = document.getElementById('shadowEnabled');
        const shadowColorInput = document.getElementById('shadowColor');

        // Background removal controls
        const removeBgEnabled = document.getElementById('removeBgEnabled');
        const bgColorSwatch = document.getElementById('bgColorSwatch');
        const bgTolerance = document.getElementById('bgTolerance');
        const bgToleranceValue = document.getElementById('bgToleranceValue');
        const pickModeHint = document.getElementById('pickModeHint');
        const autoCropEnabled = document.getElementById('autoCropEnabled');

        // Border controls
        const borderEnabled = document.getElementById('borderEnabled');
        const borderSize = document.getElementById('borderSize');
        const borderSizeValue = document.getElementById('borderSizeValue');
        const borderColor = document.getElementById('borderColor');

        function getPositionMode() {
            return document.querySelector('input[name="positionMode"]:checked').value;
        }

        let baseImage = null;
        let canvasWidth = 0;
        let canvasHeight = 0;

        // Text positions (as fractions of canvas size)
        let topTextPos = { x: 0.5, y: 0.1 };
        let bottomTextPos = { x: 0.5, y: 0.9 };

        // Background removal state
        let detectedBgColor = { r: 255, g: 255, b: 255 };
        let isPickingColor = false;

        // Detect background color by sampling corners
        function detectBackgroundColor(canvas) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const sampleSize = 5;

            // Sample from all 4 corners
            const corners = [
                ctx.getImageData(0, 0, sampleSize, sampleSize),
                ctx.getImageData(w - sampleSize, 0, sampleSize, sampleSize),
                ctx.getImageData(0, h - sampleSize, sampleSize, sampleSize),
                ctx.getImageData(w - sampleSize, h - sampleSize, sampleSize, sampleSize)
            ];

            // Average all corner pixels
            let totalR = 0, totalG = 0, totalB = 0, count = 0;
            for (const imageData of corners) {
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    totalR += data[i];
                    totalG += data[i + 1];
                    totalB += data[i + 2];
                    count++;
                }
            }

            return {
                r: Math.round(totalR / count),
                g: Math.round(totalG / count),
                b: Math.round(totalB / count)
            };
        }

        // Update the color swatch display
        function updateColorSwatch(color) {
            bgColorSwatch.style.backgroundColor = `rgb(${color.r}, ${color.g}, ${color.b})`;
        }

        // Remove background from image data
        function removeBackground(imageData, targetColor, tolerance) {
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                // Calculate color distance
                const diff = Math.abs(r - targetColor.r) +
                             Math.abs(g - targetColor.g) +
                             Math.abs(b - targetColor.b);

                if (diff <= tolerance * 3) {
                    data[i + 3] = 0; // Set alpha to transparent
                }
            }
            return imageData;
        }

        // Find bounding box of non-transparent pixels
        function findOpaqueBoundingBox(imageData) {
            const w = imageData.width;
            const h = imageData.height;
            const data = imageData.data;

            let minX = w, minY = h, maxX = 0, maxY = 0;
            let hasOpaquePixels = false;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = (y * w + x) * 4;
                    const alpha = data[idx + 3];
                    if (alpha > 0) {
                        hasOpaquePixels = true;
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                    }
                }
            }

            if (!hasOpaquePixels) {
                return null;
            }

            return {
                x: minX,
                y: minY,
                width: maxX - minX + 1,
                height: maxY - minY + 1
            };
        }

        // Create dilated border mask
        function createBorderMask(imageData, dilateAmount) {
            const w = imageData.width;
            const h = imageData.height;
            const data = imageData.data;

            // Create alpha mask (1 = opaque, 0 = transparent)
            const alphaMask = new Uint8Array(w * h);
            for (let i = 0; i < alphaMask.length; i++) {
                alphaMask[i] = data[i * 4 + 3] > 0 ? 1 : 0;
            }

            // Dilate the mask
            const dilatedMask = new Uint8Array(w * h);
            const radius = dilateAmount;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = y * w + x;
                    if (alphaMask[idx] === 1) {
                        // Original pixel is opaque, mark in dilated
                        dilatedMask[idx] = 1;
                        continue;
                    }

                    // Check if any opaque pixel is within radius
                    let foundOpaque = false;
                    for (let dy = -radius; dy <= radius && !foundOpaque; dy++) {
                        for (let dx = -radius; dx <= radius && !foundOpaque; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                                // Use circular distance for smoother border
                                if (dx * dx + dy * dy <= radius * radius) {
                                    if (alphaMask[ny * w + nx] === 1) {
                                        foundOpaque = true;
                                    }
                                }
                            }
                        }
                    }
                    dilatedMask[idx] = foundOpaque ? 2 : 0; // 2 = border pixel
                }
            }

            return { alphaMask, dilatedMask };
        }

        // Apply sticker border effect
        function applyBorder(ctx, imageData, borderPx, borderRgb) {
            const w = imageData.width;
            const h = imageData.height;

            const { dilatedMask } = createBorderMask(imageData, borderPx);

            // Create border layer
            const borderData = ctx.createImageData(w, h);
            for (let i = 0; i < dilatedMask.length; i++) {
                if (dilatedMask[i] === 2) {
                    // This is a border pixel
                    borderData.data[i * 4] = borderRgb.r;
                    borderData.data[i * 4 + 1] = borderRgb.g;
                    borderData.data[i * 4 + 2] = borderRgb.b;
                    borderData.data[i * 4 + 3] = 255;
                }
            }

            return borderData;
        }

        // Parse hex color to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 255, g: 255, b: 255 };
        }

        // Click to upload
        dropZone.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // Drag and drop
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                handleFile(e.dataTransfer.files[0]);
            }
        });

        // Paste from clipboard
        document.addEventListener('paste', (e) => {
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.startsWith('image/')) {
                    handleFile(item.getAsFile());
                    break;
                }
            }
        });

        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                showStatus('Please select an image file', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => processImage(img);
                img.onerror = () => showStatus('Failed to load image', 'error');
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function processImage(img) {
            // Calculate new dimensions
            let newWidth, newHeight;
            if (img.width > img.height) {
                newWidth = Math.min(img.width, MAX_SIZE);
                newHeight = Math.round((img.height / img.width) * newWidth);
            } else {
                newHeight = Math.min(img.height, MAX_SIZE);
                newWidth = Math.round((img.width / img.height) * newHeight);
            }

            canvasWidth = newWidth;
            canvasHeight = newHeight;

            // Create base image
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = newWidth;
            tempCanvas.height = newHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0, newWidth, newHeight);

            baseImage = new Image();
            baseImage.onload = () => {
                // Auto-detect background color from the temp canvas
                detectedBgColor = detectBackgroundColor(tempCanvas);
                updateColorSwatch(detectedBgColor);

                renderCanvas();
                editorSection.classList.add('active');
                dimensions.textContent = `${newWidth} x ${newHeight}`;
                hideStatus();
            };
            baseImage.src = tempCanvas.toDataURL();

            // Reset text positions
            topTextPos = { x: 0.5, y: 0.1 };
            bottomTextPos = { x: 0.5, y: 0.9 };
        }

        function renderCanvas() {
            if (!baseImage) return;

            // Start with base image on a temp canvas for processing
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvasWidth;
            tempCanvas.height = canvasHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(baseImage, 0, 0);

            // Get image data for processing
            let imageData = tempCtx.getImageData(0, 0, canvasWidth, canvasHeight);

            // Apply background removal if enabled
            if (removeBgEnabled.checked) {
                const tolerance = parseInt(bgTolerance.value);
                imageData = removeBackground(imageData, detectedBgColor, tolerance);
                tempCtx.putImageData(imageData, 0, 0);
            }

            // Determine final dimensions and source for drawing
            let finalWidth = canvasWidth;
            let finalHeight = canvasHeight;
            let sourceCanvas = tempCanvas;

            // Auto-crop if enabled (works with or without background removal)
            if (autoCropEnabled.checked) {
                const bbox = findOpaqueBoundingBox(imageData);
                if (bbox && (bbox.width < canvasWidth || bbox.height < canvasHeight)) {
                    // Crop to bounding box
                    const croppedCanvas = document.createElement('canvas');
                    croppedCanvas.width = bbox.width;
                    croppedCanvas.height = bbox.height;
                    const croppedCtx = croppedCanvas.getContext('2d');
                    croppedCtx.drawImage(tempCanvas, bbox.x, bbox.y, bbox.width, bbox.height, 0, 0, bbox.width, bbox.height);

                    // Resize to fit 512px
                    if (bbox.width > bbox.height) {
                        finalWidth = MAX_SIZE;
                        finalHeight = Math.round((bbox.height / bbox.width) * MAX_SIZE);
                    } else {
                        finalHeight = MAX_SIZE;
                        finalWidth = Math.round((bbox.width / bbox.height) * MAX_SIZE);
                    }

                    // Create resized canvas
                    const resizedCanvas = document.createElement('canvas');
                    resizedCanvas.width = finalWidth;
                    resizedCanvas.height = finalHeight;
                    const resizedCtx = resizedCanvas.getContext('2d');
                    resizedCtx.drawImage(croppedCanvas, 0, 0, finalWidth, finalHeight);

                    sourceCanvas = resizedCanvas;
                    imageData = resizedCtx.getImageData(0, 0, finalWidth, finalHeight);
                }
            }

            // Set output canvas dimensions
            outputCanvas.width = finalWidth;
            outputCanvas.height = finalHeight;
            const ctx = outputCanvas.getContext('2d');

            // Apply border if enabled (must be after background removal)
            if (borderEnabled.checked && removeBgEnabled.checked) {
                const borderPx = parseInt(borderSize.value);
                const borderRgb = hexToRgb(borderColor.value);
                const borderData = applyBorder(ctx, imageData, borderPx, borderRgb);

                // Draw border first (underneath)
                ctx.putImageData(borderData, 0, 0);

                // Draw processed image on top
                ctx.drawImage(sourceCanvas, 0, 0);
            } else {
                // Just draw the (possibly processed) image
                ctx.drawImage(sourceCanvas, 0, 0);
            }

            // Update dimensions display
            dimensions.textContent = `${finalWidth} x ${finalHeight}`;

            // Get text settings
            const fontSize = parseInt(fontSizeInput.value) || 36;
            const textColor = textColorInput.value;
            const shadowEnabled = shadowEnabledInput.checked;
            const shadowColor = shadowColorInput.value;

            // Set up text style
            ctx.font = `bold ${fontSize}px Impact, Arial Black, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Draw top text
            const topText = topTextInput.value;
            if (topText) {
                const topX = topTextPos.x * finalWidth;
                const topY = topTextPos.y * finalHeight;
                drawText(ctx, topText, topX, topY, textColor, shadowEnabled, shadowColor, fontSize, finalWidth);
            }

            // Draw bottom text
            const bottomText = bottomTextInput.value;
            if (bottomText) {
                const bottomX = bottomTextPos.x * finalWidth;
                const bottomY = bottomTextPos.y * finalHeight;
                drawText(ctx, bottomText, bottomX, bottomY, textColor, shadowEnabled, shadowColor, fontSize, finalWidth);
            }
        }

        function wrapText(ctx, text, maxWidth) {
            const lines = [];
            // Split by explicit line breaks first
            const paragraphs = text.split('\n');

            for (const paragraph of paragraphs) {
                if (paragraph === '') {
                    lines.push('');
                    continue;
                }
                const words = paragraph.split(' ');
                let currentLine = '';

                for (const word of words) {
                    const testLine = currentLine ? currentLine + ' ' + word : word;
                    const metrics = ctx.measureText(testLine);

                    if (metrics.width > maxWidth && currentLine) {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = testLine;
                    }
                }
                if (currentLine) {
                    lines.push(currentLine);
                }
            }
            return lines;
        }

        function drawText(ctx, text, x, y, color, shadowEnabled, shadowColor, fontSize, width) {
            const padding = 10;
            const maxWidth = width - (padding * 2);
            const lines = wrapText(ctx, text, maxWidth);
            const lineHeight = fontSize * 1.2;
            const totalHeight = lines.length * lineHeight;

            // Adjust starting Y so text block is centered on the click position
            let startY = y - (totalHeight / 2) + (lineHeight / 2);

            for (const line of lines) {
                if (shadowEnabled) {
                    // Draw shadow/outline
                    ctx.strokeStyle = shadowColor;
                    ctx.lineWidth = fontSize / 8;
                    ctx.lineJoin = 'round';
                    ctx.strokeText(line, x, startY);
                }
                // Draw text
                ctx.fillStyle = color;
                ctx.fillText(line, x, startY);
                startY += lineHeight;
            }
        }

        // Canvas drag to reposition text
        let isDragging = false;

        function updateTextPosition(e) {
            const rect = outputCanvas.getBoundingClientRect();
            const currentWidth = outputCanvas.width;
            const currentHeight = outputCanvas.height;
            const scaleX = currentWidth / rect.width;
            const scaleY = currentHeight / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            const posX = x / currentWidth;
            const posY = y / currentHeight;

            if (getPositionMode() === 'top') {
                topTextPos = { x: posX, y: posY };
            } else {
                bottomTextPos = { x: posX, y: posY };
            }

            renderCanvas();
        }

        canvasWrapper.addEventListener('mousedown', (e) => {
            // Check if we're in color picking mode
            if (isPickingColor) {
                const rect = outputCanvas.getBoundingClientRect();
                // Use original canvas dimensions for sampling from base image
                const scaleX = canvasWidth / rect.width;
                const scaleY = canvasHeight / rect.height;
                let x = Math.floor((e.clientX - rect.left) * scaleX);
                let y = Math.floor((e.clientY - rect.top) * scaleY);

                // Clamp to valid range
                x = Math.max(0, Math.min(canvasWidth - 1, x));
                y = Math.max(0, Math.min(canvasHeight - 1, y));

                // Get color from base image (not processed canvas)
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvasWidth;
                tempCanvas.height = canvasHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(baseImage, 0, 0);
                const pixel = tempCtx.getImageData(x, y, 1, 1).data;

                detectedBgColor = { r: pixel[0], g: pixel[1], b: pixel[2] };
                updateColorSwatch(detectedBgColor);

                isPickingColor = false;
                pickModeHint.style.display = 'none';
                outputCanvas.style.cursor = 'crosshair';

                renderCanvas();
                return;
            }

            isDragging = true;
            updateTextPosition(e);
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                updateTextPosition(e);
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Re-render on any change
        topTextInput.addEventListener('input', renderCanvas);
        bottomTextInput.addEventListener('input', renderCanvas);
        fontSizeInput.addEventListener('input', renderCanvas);
        textColorInput.addEventListener('input', renderCanvas);
        shadowEnabledInput.addEventListener('change', renderCanvas);
        shadowColorInput.addEventListener('input', renderCanvas);

        // Background removal controls
        removeBgEnabled.addEventListener('change', renderCanvas);
        bgTolerance.addEventListener('input', () => {
            bgToleranceValue.textContent = bgTolerance.value;
            renderCanvas();
        });
        autoCropEnabled.addEventListener('change', renderCanvas);

        // Click swatch to enter color picking mode
        bgColorSwatch.addEventListener('click', () => {
            if (!baseImage) return;
            isPickingColor = true;
            pickModeHint.style.display = 'block';
            outputCanvas.style.cursor = 'crosshair';
        });

        // Border controls
        borderEnabled.addEventListener('change', renderCanvas);
        borderSize.addEventListener('input', () => {
            borderSizeValue.textContent = borderSize.value;
            renderCanvas();
        });
        borderColor.addEventListener('input', renderCanvas);

        // Copy to clipboard
        copyBtn.addEventListener('click', async () => {
            try {
                const blob = await new Promise(resolve =>
                    outputCanvas.toBlob(resolve, 'image/png')
                );
                await navigator.clipboard.write([
                    new ClipboardItem({ 'image/png': blob })
                ]);
                showStatus('Copied to clipboard!', 'success');
            } catch (err) {
                showStatus('Failed to copy. Try using the download button instead.', 'error');
                console.error('Copy failed:', err);
            }
        });

        // Download
        downloadBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'sticker.png';
            link.href = outputCanvas.toDataURL('image/png');
            link.click();
            showStatus('Download started!', 'success');
        });

        // Reset
        resetBtn.addEventListener('click', () => {
            editorSection.classList.remove('active');
            fileInput.value = '';
            topTextInput.value = '';
            bottomTextInput.value = '';
            baseImage = null;

            // Reset background removal
            removeBgEnabled.checked = false;
            bgTolerance.value = 30;
            bgToleranceValue.textContent = '30';
            detectedBgColor = { r: 255, g: 255, b: 255 };
            updateColorSwatch(detectedBgColor);
            isPickingColor = false;
            pickModeHint.style.display = 'none';
            autoCropEnabled.checked = true;

            // Reset border
            borderEnabled.checked = false;
            borderSize.value = 5;
            borderSizeValue.textContent = '5';
            borderColor.value = '#ffffff';

            hideStatus();
        });

        function showStatus(message, type) {
            status.textContent = message;
            status.className = 'status ' + type;
        }

        function hideStatus() {
            status.className = 'status';
        }
    </script>
</body>
</html>
